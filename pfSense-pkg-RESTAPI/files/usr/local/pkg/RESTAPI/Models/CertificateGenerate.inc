<?php

namespace RESTAPI\Models;

use RESTAPI\Core\Model;
use RESTAPI\Fields\Base64Field;
use RESTAPI\Fields\ForeignModelField;
use RESTAPI\Fields\IntegerField;
use RESTAPI\Fields\StringField;
use RESTAPI\Fields\UIDField;
use RESTAPI\Responses\ServerError;
use RESTAPI\Validators\EmailAddressValidator;
use RESTAPI\Validators\HostnameValidator;
use RESTAPI\Validators\IPAddressValidator;
use RESTAPI\Validators\RegexValidator;
use RESTAPI\Validators\URLValidator;

/**
 * Defines a Model for generating new Certificates.
 */
class CertificateGenerate extends Model {
    public StringField $descr;
    public UIDField $refid;
    public IntegerField $serial;
    public ForeignModelField $caref;
    public StringField $keytype;
    public IntegerField $keylen;
    public StringField $ecname;
    public StringField $digest_alg;
    public IntegerField $lifetime;
    public StringField $dn_commonname;
    public StringField $dn_country;
    public StringField $dn_state;
    public StringField $dn_city;
    public StringField $dn_organization;
    public StringField $dn_organizationalunit;
    public StringField $type;
    public StringField $dn_dns_sans;
    public StringField $dn_email_sans;
    public StringField $dn_ip_sans;
    public StringField $dn_uri_sans;
    public Base64Field $crt;
    public Base64Field $prv;

    public function __construct(mixed $id = null, mixed $parent_id = null, mixed $data = [], mixed ...$options) {
        # Set model attributes
        $this->config_path = 'cert';
        $this->verbose_name = 'Certificate (Generated)';
        $this->verbose_name_plural = 'Certificate (Generated)';
        $this->many = true;
        $this->always_apply = true;

        # Set model fields
        $this->descr = new StringField(
            required: true,
            validators: [new RegexValidator(pattern: "/[\?\>\<\&\/\\\"\']/", invert: true)],
            help_text: 'The descriptive name for this certificate.',
        );
        $this->refid = new UIDField(
            help_text: 'The unique ID assigned to this certificate for internal system use. This value is ' .
                'generated by this system and cannot be changed.',
        );
        $this->caref = new ForeignModelField(
            model_name: 'CertificateAuthority',
            model_field: 'refid',
            required: true,
            help_text: 'The certificate authority to use as the parent for this certificate.',
        );
        $this->keytype = new StringField(
            required: true,
            choices: ['RSA', 'ECDSA'],
            representation_only: true,
            help_text: 'The type of key pair to generate.',
        );
        $this->keylen = new IntegerField(
            required: true,
            choices: [1024, 2048, 3072, 4096, 6144, 7680, 8192, 15360, 16384],
            representation_only: true,
            conditions: ['keytype' => 'RSA'],
            help_text: 'The length of the RSA key pair to generate.',
        );
        $this->ecname = new StringField(
            required: true,
            choices_callable: 'get_ecname_choices',
            representation_only: true,
            conditions: ['keytype' => 'ECDSA'],
            help_text: 'The name of the elliptic curve to use for the ECDSA key pair.',
        );
        $this->digest_alg = new StringField(
            required: true,
            choices_callable: 'get_digest_alg_choices',
            representation_only: true,
            help_text: 'The digest method used when the certificate is signed.',
        );
        $this->lifetime = new IntegerField(
            default: 3650,
            representation_only: true,
            minimum: 1,
            maximum: 12000,
            help_text: 'The number of days the certificate is valid for.',
        );
        $this->dn_commonname = new StringField(
            required: true,
            representation_only: true,
            help_text: 'The common name of the certificate.',
        );
        $this->dn_country = new StringField(
            default: '',
            choices_callable: 'get_country_choices',
            allow_empty: true,
            representation_only: true,
            help_text: 'The country of the certificate.',
        );
        $this->dn_state = new StringField(
            default: '',
            allow_empty: true,
            representation_only: true,
            help_text: 'The state/province of the certificate.',
        );
        $this->dn_city = new StringField(
            default: '',
            allow_empty: true,
            representation_only: true,
            help_text: 'The city of the certificate.',
        );
        $this->dn_organization = new StringField(
            default: '',
            allow_empty: true,
            representation_only: true,
            help_text: 'The organization of the certificate.',
        );
        $this->dn_organizationalunit = new StringField(
            default: '',
            allow_empty: true,
            representation_only: true,
            help_text: 'The organizational unit of the certificate.',
        );
        $this->type = new StringField(
            default: 'user',
            choices: ['server', 'user'],
            help_text: 'The type of certificate to generate.',
        );
        $this->dn_dns_sans = new StringField(
            default: [],
            allow_empty: true,
            representation_only: true,
            many: true,
            validators: [new HostnameValidator(allow_hostname: true, allow_domain: true, allow_fqdn: true)],
            help_text: 'The DNS Subject Alternative Names (SANs) for the certificate.',
        );
        $this->dn_email_sans = new StringField(
            default: [],
            allow_empty: true,
            representation_only: true,
            many: true,
            validators: [new EmailAddressValidator()],
            help_text: 'The Email Subject Alternative Names (SANs) for the certificate.',
        );
        $this->dn_ip_sans = new StringField(
            default: [],
            allow_empty: true,
            representation_only: true,
            many: true,
            validators: [new IPAddressValidator(allow_ipv4: true, allow_ipv6: true)],
            help_text: 'The IP Subject Alternative Names (SANs) for the certificate.',
        );
        $this->dn_uri_sans = new StringField(
            default: [],
            allow_empty: true,
            representation_only: true,
            many: true,
            validators: [new URLValidator()],
            help_text: 'The URI Subject Alternative Names (SANs) for the certificate.',
        );
        $this->crt = new Base64Field(
            default: null,
            allow_null: true,
            read_only: true,
            help_text: 'The X509 certificate string.',
        );
        $this->prv = new Base64Field(
            default: null,
            allow_null: true,
            read_only: true,
            sensitive: true,
            help_text: 'The X509 private key string.',
        );

        parent::__construct($id, $parent_id, $data, ...$options);
    }

    /**
     * Returns a list of available elliptic curve names for ECDSA key pairs.
     * @returns array The list of available elliptic curve names.
     */
    public static function get_ecname_choices(): array {
        # Obtain the available curve list from pfSense's built-in cert_build_curve_list function
        return array_keys(cert_build_curve_list());
    }

    /**
     * Returns a list of available digest algorithms for signing certificates.
     * @returns array The list of available digest algorithms.
     */
    public static function get_digest_alg_choices(): array {
        # Obtain the available digest algorithms from pfSense's built-in $openssl_digest_algs global
        global $openssl_digest_algs;
        return $openssl_digest_algs;
    }

    /**
     * Returns a list of available country codes for the certificate.
     * @returns array The list of available country codes.
     */
    public static function get_country_choices(): array {
        # Obtain the available country codes from pfSense's built-in get_cert_country_codes function
        return array_keys(get_cert_country_codes());
    }

    /**
     * Extends the default _create method to ensure the certificate is generated before it is written to config.
     */
    protected function _create(): void {
        # Generate the certificate
        $this->generate_cert();

        # Call the parent _create method to write the certificate to config
        parent::_create();
    }

    /**
     * Converts this Certificate object's DN values into a X509 DN array.
     * @returns array The X509 DN array.
     */
    private function to_x509_dn(): array {
        # Define static DN values
        $dn = [
            'commonName' => $this->dn_commonname->value,
            'countryName' => $this->dn_country->value,
            'stateOrProvinceName' => $this->dn_state->value,
            'localityName' => $this->dn_city->value,
            'organizationName' => $this->dn_organization->value,
            'organizationalUnitName' => $this->dn_organizationalunit->value,
            'subjectAltName' => [],
        ];

        # Loop through the SAN fields and add them to the subjectAltName array accordingly
        foreach ($this->dn_dns_sans->value as $san) {
            $dn['subjectAltName'][] = "DNS:$san";
        }
        foreach ($this->dn_email_sans->value as $san) {
            $dn['subjectAltName'][] = "email:$san";
        }
        foreach ($this->dn_ip_sans->value as $san) {
            $dn['subjectAltName'][] = "IP:$san";
        }
        foreach ($this->dn_uri_sans->value as $san) {
            $dn['subjectAltName'][] = "URI:$san";
        }

        # Piece together the subjectAltName array into a comma-separated string
        $dn['subjectAltName'] = implode(',', $dn['subjectAltName']);

        return $dn;
    }

    /**
     * Generates a new certificate and key pair using the requested parameters. This populate the `crt` and `prv` fields.
     * @throws ServerError When the cert certificate and key pair fails to be generated.
     */
    private function generate_cert(): void {
        # Define a placeholder for create_cert() to populate
        $cert = [];

        # Generate the certificate and key pair
        $success = cert_create(
            cert: $cert,
            caref: $this->caref->value,
            lifetime: $this->lifetime->value,
            dn: $this->to_x509_dn(),
            type: $this->type->value,
            digest_alg: $this->digest_alg->value,
            keytype: $this->keytype->value,
            keylen: $this->keylen->value,
            ecname: $this->ecname->value,
        );

        # Throw a server error if the certificate and key pair fails to be generated
        if (!$success) {
            throw new ServerError(
                message: 'Failed to generate the certificate for unknown reason.',
                response_id: 'CERTIFICATE_GENERATE_FAILED',
            );
        }

        # Populate the `crt` and `prv` fields with the generated values
        $this->crt->from_internal($cert['crt']);
        $this->prv->from_internal($cert['prv']);
    }
}
