<?php

namespace RESTAPI\Models;

use RESTAPI\Core\Auth;
use RESTAPI\Core\Model;
use RESTAPI\Fields\Base64Field;
use RESTAPI\Fields\BooleanField;
use RESTAPI\Fields\IntegerField;
use RESTAPI\Fields\StringField;
use RESTAPI\Fields\UIDField;
use RESTAPI\Responses\ForbiddenError;
use RESTAPI\Responses\ValidationError;
use RESTAPI\Validators\RegexValidator;
use RESTAPI\Validators\X509Validator;

class CertificateAuthority extends Model
{
    public StringField $descr;
    public UIDField $refid;
    public BooleanField $trust;
    public BooleanField $randomserial;
    public IntegerField $serial;
    public Base64Field $crt;
    public Base64Field $prv;

    public function __construct(mixed $id = null, mixed $data = [], mixed ...$options)
    {
        # Set model attributes
        $this->config_path = "ca";
        $this->many = true;
        $this->always_apply = true;

        # Set model fields
        $this->descr = new StringField(
            required: true,
            validators: [new RegexValidator(pattern: "/[\?\>\<\&\/\\\"\']/", invert: true)],
            help_text: "The descriptive name for this certificate authority."
        );
        $this->refid = new UIDField(
            help_text: "The unique ID assigned to this certificate authority for internal system use. This value is ".
                "generated by this system and cannot be changed."
        );
        $this->trust = new BooleanField(
            default: false,
            indicates_true: "enabled",
            help_text: "Adds or removes this certificate authority from the operating system's trust stored."
        );
        $this->randomserial = new BooleanField(
            default: false,
            indicates_true: "enabled",
            help_text: "Enables or disables the randomization of serial numbers for certificates signed by this CA."
        );
        $this->serial = new IntegerField(
            default: 1,
            minimum: 1,
            help_text: "The decimal number to be used as a sequential serial number for the next certificate to be ".
                "signed by this CA. This value is ignored when Randomize Serial is checked."
        );
        $this->crt = new Base64Field(
            required: true,
            validators: [new X509Validator(allow_crt: true)],
            help_text: "The X509 certificate string."
        );
        $this->prv = new Base64Field(
            required: true,
            write_only: true,
            validators: [new X509Validator(allow_prv: true, allow_ecprv: true)],
            help_text: "The X509 private key string."
        );

        parent::__construct(...$options, id: $id,  data: $data);
    }

    /**
     * Adds extra validation to the `crt` field
     * @param string $crt The incoming value to be validated.
     * @returns string The validated value to be set.
     * @throws ValidationError When $crt is not capable of operating as a Certificate Authority
     */
    public function validate_crt(string $crt): string {
        # Do not allow this $crt if it is not capable of operating as a Certificate Authority
        if (cert_get_purpose($crt, decode: false)["ca"] !== "Yes") {
            throw new ValidationError(
                message: "Field `crt` value cannot be used because it does not appear to be a Certificate Authority.",
                response_id: "CERTIFICATE_AUTHORITY_CRT_NOT_VALID_CA"
            );
        }

        return $crt;
    }

    /**
     * Adds extra validation to the `prv` field.
     * @param string $prv The incoming value to be validated.
     * @returns string The validated value to be set.
     * @throws ValidationError When $prv and the `crt` field's current value are not a matching key pair
     */
    public function validate_prv(string $prv): string {
        # Throw a validation error if $prv and the `crt` field's current value are not a matching key pair
        if (!X509Validator::is_matching_keypair(public_key: $this->crt->value, private_key: $prv)) {
            throw new ValidationError(
                message: "Field `prv` and field `crt` values must be a matching key pair.",
                response_id: "CERTIFICATE_AUTHORITY_CRT_AND_PRV_NOT_KEYPAIR"
            );
        }

        return $prv;
    }

    /**
     * Deletes this CertificateAuthority object from configuration.
     * @throws ForbiddenError When the CertificateAuthority cannot be deleted because it is in use.
     */
    public function _delete(): void
    {
        # Do not allow this CertificateAuthority to be deleted if it is in use
        if (cert_in_use($this->refid->value)){
            throw new ForbiddenError(
                message: "Certificate authority cannot be deleted because it is in use.",
                response_id: "CERTIFICATE_AUTHORITY_CANNOT_BE_DELETED_WHILE_IN_USE"
            );
        }

        parent::_delete();
    }

    /**
     * Apply CA changes to the OS trust store.
     */
    public function apply() {
        ca_setup_trust_store();
    }
}
