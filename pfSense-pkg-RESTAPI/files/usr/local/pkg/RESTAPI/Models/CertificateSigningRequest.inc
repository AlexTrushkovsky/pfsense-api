<?php

namespace RESTAPI\Models;

use RESTAPI\Core\Model;
use RESTAPI\Fields\Base64Field;
use RESTAPI\Fields\IntegerField;
use RESTAPI\Fields\StringField;
use RESTAPI\Fields\UIDField;
use RESTAPI\ModelTraits\CertificateModelTraits;
use RESTAPI\Responses\ServerError;
use RESTAPI\Validators\EmailAddressValidator;
use RESTAPI\Validators\HostnameValidator;
use RESTAPI\Validators\IPAddressValidator;
use RESTAPI\Validators\RegexValidator;
use RESTAPI\Validators\URLValidator;

/**
 * Defines a Model for generating new CSRs.
 */
class CertificateSigningRequest extends Model {
    use CertificateModelTraits;

    public StringField $descr;
    public UIDField $refid;
    public IntegerField $serial;
    public StringField $keytype;
    public IntegerField $keylen;
    public StringField $ecname;
    public StringField $digest_alg;
    public IntegerField $lifetime;
    public StringField $dn_commonname;
    public StringField $dn_country;
    public StringField $dn_state;
    public StringField $dn_city;
    public StringField $dn_organization;
    public StringField $dn_organizationalunit;
    public StringField $type;
    public StringField $dn_dns_sans;
    public StringField $dn_email_sans;
    public StringField $dn_ip_sans;
    public StringField $dn_uri_sans;
    public Base64Field $csr;
    public Base64Field $prv;

    public function __construct(mixed $id = null, mixed $parent_id = null, mixed $data = [], mixed ...$options) {
        # Set model attributes
        $this->config_path = 'cert';
        $this->many = true;
        $this->always_apply = true;

        # Set model fields
        $this->descr = new StringField(
            required: true,
            validators: [new RegexValidator(pattern: "/[\?\>\<\&\/\\\"\']/", invert: true)],
            help_text: 'The descriptive name for this certificate.',
        );
        $this->refid = new UIDField(
            help_text: 'The unique ID assigned to this certificate for internal system use. This value is ' .
                'generated by this system and cannot be changed.',
        );
        $this->keytype = new StringField(
            required: true,
            choices: ['RSA', 'ECDSA'],
            representation_only: true,
            help_text: 'The type of key pair to generate.',
        );
        $this->keylen = new IntegerField(
            required: true,
            choices: [1024, 2048, 3072, 4096, 6144, 7680, 8192, 15360, 16384],
            representation_only: true,
            conditions: ['keytype' => 'RSA'],
            help_text: 'The length of the RSA key pair to generate.',
        );
        $this->ecname = new StringField(
            required: true,
            choices_callable: 'get_ecname_choices',
            representation_only: true,
            conditions: ['keytype' => 'ECDSA'],
            help_text: 'The name of the elliptic curve to use for the ECDSA key pair.',
        );
        $this->digest_alg = new StringField(
            required: true,
            choices_callable: 'get_digest_alg_choices',
            representation_only: true,
            help_text: 'The digest method used when the certificate is signed.',
        );
        $this->lifetime = new IntegerField(
            default: 3650,
            representation_only: true,
            minimum: 1,
            maximum: 12000,
            help_text: 'The number of days the certificate is valid for.',
        );
        $this->dn_commonname = new StringField(
            required: true,
            representation_only: true,
            help_text: 'The common name of the certificate.',
        );
        $this->dn_country = new StringField(
            default: null,
            choices_callable: 'get_country_choices',
            allow_null: true,
            representation_only: true,
            help_text: 'The country of the certificate.',
        );
        $this->dn_state = new StringField(
            default: null,
            allow_null: true,
            representation_only: true,
            help_text: 'The state/province of the certificate.',
        );
        $this->dn_city = new StringField(
            default: null,
            allow_null: true,
            representation_only: true,
            help_text: 'The city of the certificate.',
        );
        $this->dn_organization = new StringField(
            default: null,
            allow_null: true,
            representation_only: true,
            help_text: 'The organization of the certificate.',
        );
        $this->dn_organizationalunit = new StringField(
            default: null,
            allow_null: true,
            representation_only: true,
            help_text: 'The organizational unit of the certificate.',
        );
        $this->type = new StringField(
            default: 'user',
            choices: ['server', 'user'],
            help_text: 'The type of certificate to generate.',
        );
        $this->dn_dns_sans = new StringField(
            default: [],
            allow_empty: true,
            representation_only: true,
            many: true,
            validators: [new HostnameValidator(allow_hostname: true, allow_domain: true, allow_fqdn: true)],
            help_text: 'The DNS Subject Alternative Names (SANs) for the certificate.',
        );
        $this->dn_email_sans = new StringField(
            default: [],
            allow_empty: true,
            representation_only: true,
            many: true,
            validators: [new EmailAddressValidator()],
            help_text: 'The Email Subject Alternative Names (SANs) for the certificate.',
        );
        $this->dn_ip_sans = new StringField(
            default: [],
            allow_empty: true,
            representation_only: true,
            many: true,
            validators: [new IPAddressValidator(allow_ipv4: true, allow_ipv6: true)],
            help_text: 'The IP Subject Alternative Names (SANs) for the certificate.',
        );
        $this->dn_uri_sans = new StringField(
            default: [],
            allow_empty: true,
            representation_only: true,
            many: true,
            validators: [new URLValidator()],
            help_text: 'The URI Subject Alternative Names (SANs) for the certificate.',
        );
        $this->csr = new Base64Field(
            default: null,
            allow_null: true,
            read_only: true,
            help_text: 'The X509 certificate signing request string. You will need to provide this to a ' .
                'certificate authority to sign the certificate.',
        );
        $this->prv = new Base64Field(
            default: null,
            allow_null: true,
            read_only: true,
            sensitive: true,
            help_text: 'The X509 private key string.',
        );

        parent::__construct($id, $parent_id, $data, ...$options);
    }

    /**
     * Extends the default _create method to ensure the certificate is generated before it is written to config.
     */
    protected function _create(): void {
        # Generate the certificate
        $this->generate_csr();

        # Call the parent _create method to write the certificate to config
        parent::_create();
    }

    /**
     * Generates a new CSR and key using the requested parameters. This populate the `csr` and `prv` fields.
     * @throws ServerError When the CSR and key fails to be generated.
     */
    private function generate_csr(): void {
        # Define a placeholder for csr_generate() to populate
        $csr = [];

        # Generate the CSR and key pair
        $success = csr_generate(
            cert: $csr,
            keylen: $this->keylen->value,
            dn: $this->to_x509_dn($this),
            type: $this->type->value,
            digest_alg: $this->digest_alg->value,
            keytype: $this->keytype->value,
            ecname: $this->ecname->value,
        );

        # Throw a server error if the CSR and key fails to be generated
        if (!$success) {
            throw new ServerError(
                message: 'Failed to generate the certificate signing request for unknown reason.',
                response_id: 'CERTIFICATE_SIGNING_REQUEST_GENERATE_FAILED',
            );
        }

        # Populate the `csr` and `prv` fields with the generated values
        $this->csr->from_internal($csr['csr']);
        $this->prv->from_internal($csr['prv']);
    }
}
